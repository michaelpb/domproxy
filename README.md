# vdomproxy

Dom diff proxy &amp; client

**NOTE:** Not even remotely yet to MVP / prototype, this README is mostly
documenting what I am intending to build.

## Vision

Think Turbolinks, but with WebSockets + VDOM + push refresh

### Description

A upstream proxy and client-side JavaScript library that speeds up and smooths
out the experience using existing multi page apps built with any language or
framework, with minimal changes to no changes, and also provide a
framework-agnostic "magic" live-refresh feature.

### Rationale

I prefer writing "traditional" multipage web-apps using Python / Django. The
industry already runs on server-side frameworks like Ruby on Rails or PHP. While
the upsides of server-side rendering are immense (fast first page load speed, low
client system requirements and memory footprint, much easier SEO, easier e2e
testing etc) they have their downsides: Actions like clicking on a link loads
unnecessary amounts of data over the wire, have worse user experiences when
navigating (no loading spinner or transition effects available), and
live-refresh through websockets turns into a clunky mix of JavaScript,
third-party APIs and/or extra app servers.

I'm writing `vdomproxy` as a to provide React-like VDom diff / patch cycle, but
on the backend, in a framework agnostic way, and providing for clever

### Structure

Basic structure:

```
 ________                                                ___________
|        |      initial HTTP request                    |           |
| Client |   --------------------------------------->   | Web app   |
|        |                                              |           |
|        |                                              | (in any   |
|        |    websocket     ___________    http rqst    |  lang/    |
|        |   <---------->  | vdomproxy |  ---------->   | framework)|
|________|                 |___________|  (subsequent)  |___________|
```

Protocol:

1. Client retrieves page normally with HTTP request
2. Client loads frontend script (`vdomproxy-frontend.js`)
    - This opens websocket connection to `vdomproxy` (ideally co-located in
      same datacenter or even the same VM as the web-app).
    - The first thing it sends is the current HTML document to the vdomproxy,
      which parses it into a virtual DOM that's stored in local memory.
    - Frontend script upgrades `<a href=...>` anchor tags to instead send
      equivalent request over the websocket on click

3. On a subsequent click, vdomproxy responds with a DOM patch, which client
applies
    - Instead of sending back entire HTML page, the vdomproxy will diff the DOM
      generated by the new HTML request, and then only send back the diff (the
      "patch") to the frontend. If the vdomproxy and web app are colocated,
      this greatly reduces bandwidth usage.
    - The frontend in turn will apply all patches received to the DOM to update
      it to the new page

-----

Live update protocol:

Whenever the backend's templating engine generates some elements with special
attributes, something like:

```html
<div vdomproxy-liverefresh="true">
    ...
</div>
```

Then, whenever it serves up this element at a certain URL with new content, it
will, "magically" update for everyone else.

This is the basic principle -- there will be other ways to customize how
elements get uniquely identified for live-update (e.g. if they are only visible
while people are logged in, etc), along with a REST API to force updates of
DOM elements based on those unique identifiers.

